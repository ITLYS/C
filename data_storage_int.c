#include <stdio.h>
/*C语言：数据存储---整型存储*/
int main()
{
    return 0;
}
/*
*注：a.整型基本分为：char short int long；
*   b.各种整型又分为有符号位（signed） 和无符号位（unsigned），不标记默认：有符号位
*   c.有符号位：分为正整数 和负整数；无符号位只有正整数；
*   d.正整数：原码 == 反码 == 补码；
*   e.负整数：原码：十进制整数转化为32个bit位的2进制序列 （首位数值：正整数 0，负整数 1）
*            反码：原码的基础上  最高位不变，其他位取反
*            补码：反码的基础上 +1
*   f.内存中存储数据的形式：补码
*   g.根据类型的不同所存补码的字节数各不相同；例如 char 1个字节 == 8 bit  只能存储 00000011
*   h.数值取出的时候，需要进行整形提升 拿char举例：
*                          存储补码格式 00000011 ，最高位为0，最高位左边补齐0到32个为止
*                          存储补码格式 10000011 ，最高位为1，最高位左边补齐1到32个为止
*    此时补齐之后仍是 补码 需要根据有无符号位的形式判断是否转化为 原码
*/
/*
*整型数据存储实例 2.
*
*/
void fun2(){
    //char a = -128;//等效于 signed char a,有符号的范围是-128 ~ 127  00000010
    //源码  10000000000000000000000010000000
    //反码  11111111111111111111111101111111
    //补码  11111111111111111111111110000000
    //最后存储  10000000
    //整型提升  补码 11111111111111111111111110000000  由于%u无符号位  直接转化为十进制整型
    //char b = 128;   // char 类型 等效于 signed char 范围-128 ~127
    //源码  00000000000000000000000010000000  原反补都一样
    //最后存储  10000000
    //整型提升  补码 11111111111111111111111110000000  由于%u无符号位  直接转化为十进制整型
   // printf("%u\n%u", a,b);
}
/*
*整型数据存储实例 1.
*
*/
void fun1(){
    char a = -1;//10000000000000000000000000000001 原码
                //11111111111111111111111111111110 反码
                //11111111111111111111111111111111 补码
                //实际只能保存11111111
                //11111111111111111111111111111111 整型提升 补码
                //11111111111111111111111111111110 反码
                //10000000000000000000000000000001 原码

    signed char b = -1;//和上个例子一样

    unsigned char c = -1;//
                    //10000000000000000000000000000001 原码
                    //11111111111111111111111111111110 反码
                    //11111111111111111111111111111111 补码
                    //实际只能保存11111111
                    //注意到无符号 则整型提升时00000000000000000000000011111111 补码=反码=原码

    printf("%d %d %d", a, b, c);
}
